
carrinho.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000020  00800100  00000aac  00000b40  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000aac  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000009  00800120  00800120  00000b60  2**0
                  ALLOC
  3 .stab         000021e4  00000000  00000000  00000b60  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001c35  00000000  00000000  00002d44  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .comment      00000011  00000000  00000000  00004979  2**0
                  CONTENTS, READONLY
  6 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000498c  2**2
                  CONTENTS, READONLY
  7 .debug_aranges 000000a0  00000000  00000000  000049d0  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   000006b2  00000000  00000000  00004a70  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 00000606  00000000  00000000  00005122  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   0000038e  00000000  00000000  00005728  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    0000026d  00000000  00000000  00005ab6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 03 03 	jmp	0x606	; 0x606 <__vector_24>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	ec ea       	ldi	r30, 0xAC	; 172
  7c:	fa e0       	ldi	r31, 0x0A	; 10
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a0 32       	cpi	r26, 0x20	; 32
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a0 e2       	ldi	r26, 0x20	; 32
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	a9 32       	cpi	r26, 0x29	; 41
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 1a 01 	call	0x234	; 0x234 <main>
  9e:	0c 94 54 05 	jmp	0xaa8	; 0xaa8 <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <adc_init>:
#include "../lib/bits.h"

#include "../lib/avr_usart.h"
#include "../lib/adc_battery.h"

void adc_init(){
  a6:	cf 93       	push	r28
  a8:	df 93       	push	r29
  aa:	cd b7       	in	r28, 0x3d	; 61
  ac:	de b7       	in	r29, 0x3e	; 62

	/* Ref externa no pino AVCC com capacitor de 100n em VREF.
	 * Habiltiação apenas no Canal 0 */
	ADCS->AD_MUX = SET(REFS0);     // 5v ref
  ae:	88 e7       	ldi	r24, 0x78	; 120
  b0:	90 e0       	ldi	r25, 0x00	; 0
  b2:	20 e4       	ldi	r18, 0x40	; 64
  b4:	fc 01       	movw	r30, r24
  b6:	24 83       	std	Z+4, r18	; 0x04
	/* Habilita AD:
	 * Conversão contínua
	 * IRQ ativo
	 * Prescaler de 128 */
	ADCS->ADC_SRA = SET(ADEN)  |	//ADC Enable
  b8:	88 e7       	ldi	r24, 0x78	; 120
  ba:	90 e0       	ldi	r25, 0x00	; 0
  bc:	2f ee       	ldi	r18, 0xEF	; 239
  be:	fc 01       	movw	r30, r24
  c0:	22 83       	std	Z+2, r18	; 0x02
					SET(ADATE) |	// ADC Auto Trigger
					SET(ADPS0) | SET(ADPS1) | SET(ADPS2) | //ADPS[0..2] AD Prescaler selection prsc = 128
					SET(ADIE); 		//AD IRQ ENABLE

	/* Desabilita hardware digital de PC0 */
	ADCS->DIDr0.BITS.ADC0 = 1;
  c2:	88 e7       	ldi	r24, 0x78	; 120
  c4:	90 e0       	ldi	r25, 0x00	; 0
  c6:	fc 01       	movw	r30, r24
  c8:	26 81       	ldd	r18, Z+6	; 0x06
  ca:	21 60       	ori	r18, 0x01	; 1
  cc:	fc 01       	movw	r30, r24
  ce:	26 83       	std	Z+6, r18	; 0x06

}
  d0:	00 00       	nop
  d2:	df 91       	pop	r29
  d4:	cf 91       	pop	r28
  d6:	08 95       	ret

000000d8 <SPI_MasterInit>:
#define MISO PB4
#define SCK PB5

/*\ Inicialização do SPÌ */
void SPI_MasterInit(void)
{
  d8:	cf 93       	push	r28
  da:	df 93       	push	r29
  dc:	cd b7       	in	r28, 0x3d	; 61
  de:	de b7       	in	r29, 0x3e	; 62
	/* Configura direção das portas */
	GPIO_B->DDR = (1 << SS) | (1 << MOSI) | (1 << SCK);
  e0:	83 e2       	ldi	r24, 0x23	; 35
  e2:	90 e0       	ldi	r25, 0x00	; 0
  e4:	2c e2       	ldi	r18, 0x2C	; 44
  e6:	fc 01       	movw	r30, r24
  e8:	21 83       	std	Z+1, r18	; 0x01

	/* Ativa SPI em modo mestre
	 * clock = F_CPU / 16  */
	SPI->SP_CR.MASK = SET(SPE) | SET(MSTR) | SET(SPR0)  | SET(DORD);
  ea:	8c e4       	ldi	r24, 0x4C	; 76
  ec:	90 e0       	ldi	r25, 0x00	; 0
  ee:	21 e7       	ldi	r18, 0x71	; 113
  f0:	fc 01       	movw	r30, r24
  f2:	20 83       	st	Z, r18
	/* Diretamente:
	SPCR = (1 << SPE)|(1 << MSTR)|(1 << SPR0); */
}
  f4:	00 00       	nop
  f6:	df 91       	pop	r29
  f8:	cf 91       	pop	r28
  fa:	08 95       	ret

000000fc <SPI_Transmit>:

uint8_t SPI_Transmit(uint8_t byte){
  fc:	cf 93       	push	r28
  fe:	df 93       	push	r29
 100:	0f 92       	push	r0
 102:	cd b7       	in	r28, 0x3d	; 61
 104:	de b7       	in	r29, 0x3e	; 62
 106:	89 83       	std	Y+1, r24	; 0x01

	/* Configura dado no registrado de hardware */
	//SPI->SP_DR = byte;
	/* Diretamente: */
	SPDR = byte;
 108:	8e e4       	ldi	r24, 0x4E	; 78
 10a:	90 e0       	ldi	r25, 0x00	; 0
 10c:	29 81       	ldd	r18, Y+1	; 0x01
 10e:	fc 01       	movw	r30, r24
 110:	20 83       	st	Z, r18

	/* Aguarada transmissão */
	while (!SPI->SP_SR.SP_IF);
 112:	00 00       	nop
 114:	8c e4       	ldi	r24, 0x4C	; 76
 116:	90 e0       	ldi	r25, 0x00	; 0
 118:	fc 01       	movw	r30, r24
 11a:	81 81       	ldd	r24, Z+1	; 0x01
 11c:	87 fb       	bst	r24, 7
 11e:	88 27       	eor	r24, r24
 120:	80 f9       	bld	r24, 0
 122:	88 23       	and	r24, r24
 124:	b9 f3       	breq	.-18     	; 0x114 <SPI_Transmit+0x18>
	/* Diretamente: */
	//while(!(SPSR & (1<<SPIF)));

	/* retorna se algum dado for lido */
	return SPI->SP_DR;
 126:	8c e4       	ldi	r24, 0x4C	; 76
 128:	90 e0       	ldi	r25, 0x00	; 0
 12a:	fc 01       	movw	r30, r24
 12c:	82 81       	ldd	r24, Z+2	; 0x02
}
 12e:	0f 90       	pop	r0
 130:	df 91       	pop	r29
 132:	cf 91       	pop	r28
 134:	08 95       	ret

00000136 <SPI_SlaveReceive>:

uint8_t SPI_SlaveReceive(uint8_t byte)
{
 136:	cf 93       	push	r28
 138:	df 93       	push	r29
 13a:	0f 92       	push	r0
 13c:	cd b7       	in	r28, 0x3d	; 61
 13e:	de b7       	in	r29, 0x3e	; 62
 140:	89 83       	std	Y+1, r24	; 0x01
	// Uma recepção de SPI deve ativar o clock
	// logo, enviamos outro dado ou qualquer coisa
	return SPI_Transmit(byte);
 142:	89 81       	ldd	r24, Y+1	; 0x01
 144:	0e 94 7e 00 	call	0xfc	; 0xfc <SPI_Transmit>
}
 148:	0f 90       	pop	r0
 14a:	df 91       	pop	r29
 14c:	cf 91       	pop	r28
 14e:	08 95       	ret

00000150 <get_usart_stream>:

/* Stream init for printf  */
FILE usart_str = FDEV_SETUP_STREAM(usart_putchar, NULL, _FDEV_SETUP_WRITE);

/* Return stream pointer  */
FILE * get_usart_stream(){
 150:	cf 93       	push	r28
 152:	df 93       	push	r29
 154:	cd b7       	in	r28, 0x3d	; 61
 156:	de b7       	in	r29, 0x3e	; 62
	return &usart_str;
 158:	80 e0       	ldi	r24, 0x00	; 0
 15a:	91 e0       	ldi	r25, 0x01	; 1
}
 15c:	df 91       	pop	r29
 15e:	cf 91       	pop	r28
 160:	08 95       	ret

00000162 <USART_Init>:

void USART_Init(uint16_t bauds){
 162:	cf 93       	push	r28
 164:	df 93       	push	r29
 166:	00 d0       	rcall	.+0      	; 0x168 <USART_Init+0x6>
 168:	cd b7       	in	r28, 0x3d	; 61
 16a:	de b7       	in	r29, 0x3e	; 62
 16c:	9a 83       	std	Y+2, r25	; 0x02
 16e:	89 83       	std	Y+1, r24	; 0x01

	USART_0->UBRR_H = (uint8_t) (bauds >> 8);
 170:	89 81       	ldd	r24, Y+1	; 0x01
 172:	9a 81       	ldd	r25, Y+2	; 0x02
 174:	29 2f       	mov	r18, r25
 176:	33 27       	eor	r19, r19
 178:	80 ec       	ldi	r24, 0xC0	; 192
 17a:	90 e0       	ldi	r25, 0x00	; 0
 17c:	fc 01       	movw	r30, r24
 17e:	25 83       	std	Z+5, r18	; 0x05
	USART_0->UBRR_L = bauds;
 180:	80 ec       	ldi	r24, 0xC0	; 192
 182:	90 e0       	ldi	r25, 0x00	; 0
 184:	29 81       	ldd	r18, Y+1	; 0x01
 186:	fc 01       	movw	r30, r24
 188:	24 83       	std	Z+4, r18	; 0x04

	/* Disable double speed  */
	USART_0->UCSR_A = 0;
 18a:	80 ec       	ldi	r24, 0xC0	; 192
 18c:	90 e0       	ldi	r25, 0x00	; 0
 18e:	fc 01       	movw	r30, r24
 190:	10 82       	st	Z, r1
	/* Enable TX and RX */
	USART_0->UCSR_B = SET(RXEN0) | SET(TXEN0) | SET(RXCIE0);
 192:	80 ec       	ldi	r24, 0xC0	; 192
 194:	90 e0       	ldi	r25, 0x00	; 0
 196:	28 e9       	ldi	r18, 0x98	; 152
 198:	fc 01       	movw	r30, r24
 19a:	21 83       	std	Z+1, r18	; 0x01
	/* Asynchronous mode:
	 * - 8 data bits
	 * - 1 stop bit
	 * - no parity 	 */
	USART_0->UCSR_C = SET(UCSZ01) | SET(UCSZ00);
 19c:	80 ec       	ldi	r24, 0xC0	; 192
 19e:	90 e0       	ldi	r25, 0x00	; 0
 1a0:	26 e0       	ldi	r18, 0x06	; 6
 1a2:	fc 01       	movw	r30, r24
 1a4:	22 83       	std	Z+2, r18	; 0x02
}
 1a6:	00 00       	nop
 1a8:	0f 90       	pop	r0
 1aa:	0f 90       	pop	r0
 1ac:	df 91       	pop	r29
 1ae:	cf 91       	pop	r28
 1b0:	08 95       	ret

000001b2 <USART_tx>:


/* Send one byte: busy waiting */
void USART_tx(uint8_t data) {
 1b2:	cf 93       	push	r28
 1b4:	df 93       	push	r29
 1b6:	0f 92       	push	r0
 1b8:	cd b7       	in	r28, 0x3d	; 61
 1ba:	de b7       	in	r29, 0x3e	; 62
 1bc:	89 83       	std	Y+1, r24	; 0x01

	/* Wait until hardware is ready */
	while (!(USART_0->UCSR_A & (1 << UDRE0)));
 1be:	00 00       	nop
 1c0:	80 ec       	ldi	r24, 0xC0	; 192
 1c2:	90 e0       	ldi	r25, 0x00	; 0
 1c4:	fc 01       	movw	r30, r24
 1c6:	80 81       	ld	r24, Z
 1c8:	88 2f       	mov	r24, r24
 1ca:	90 e0       	ldi	r25, 0x00	; 0
 1cc:	80 72       	andi	r24, 0x20	; 32
 1ce:	99 27       	eor	r25, r25
 1d0:	89 2b       	or	r24, r25
 1d2:	b1 f3       	breq	.-20     	; 0x1c0 <USART_tx+0xe>

	USART_0->UDR_ = data;
 1d4:	80 ec       	ldi	r24, 0xC0	; 192
 1d6:	90 e0       	ldi	r25, 0x00	; 0
 1d8:	29 81       	ldd	r18, Y+1	; 0x01
 1da:	fc 01       	movw	r30, r24
 1dc:	26 83       	std	Z+6, r18	; 0x06
}
 1de:	00 00       	nop
 1e0:	0f 90       	pop	r0
 1e2:	df 91       	pop	r29
 1e4:	cf 91       	pop	r28
 1e6:	08 95       	ret

000001e8 <USART_rx>:

/* Receive one byte: busy waiting */
uint8_t USART_rx() {
 1e8:	cf 93       	push	r28
 1ea:	df 93       	push	r29
 1ec:	cd b7       	in	r28, 0x3d	; 61
 1ee:	de b7       	in	r29, 0x3e	; 62

	/* Wait until something arrive  */
	while (!(USART_0->UCSR_A & (1 << RXC0)));
 1f0:	00 00       	nop
 1f2:	80 ec       	ldi	r24, 0xC0	; 192
 1f4:	90 e0       	ldi	r25, 0x00	; 0
 1f6:	fc 01       	movw	r30, r24
 1f8:	80 81       	ld	r24, Z
 1fa:	88 23       	and	r24, r24
 1fc:	d4 f7       	brge	.-12     	; 0x1f2 <USART_rx+0xa>

	return USART_0->UDR_;
 1fe:	80 ec       	ldi	r24, 0xC0	; 192
 200:	90 e0       	ldi	r25, 0x00	; 0
 202:	fc 01       	movw	r30, r24
 204:	86 81       	ldd	r24, Z+6	; 0x06
}
 206:	df 91       	pop	r29
 208:	cf 91       	pop	r28
 20a:	08 95       	ret

0000020c <usart_putchar>:


static int usart_putchar(char c, FILE *fp){
 20c:	cf 93       	push	r28
 20e:	df 93       	push	r29
 210:	00 d0       	rcall	.+0      	; 0x212 <usart_putchar+0x6>
 212:	0f 92       	push	r0
 214:	cd b7       	in	r28, 0x3d	; 61
 216:	de b7       	in	r29, 0x3e	; 62
 218:	89 83       	std	Y+1, r24	; 0x01
 21a:	7b 83       	std	Y+3, r23	; 0x03
 21c:	6a 83       	std	Y+2, r22	; 0x02
	USART_tx(c);
 21e:	89 81       	ldd	r24, Y+1	; 0x01
 220:	0e 94 d9 00 	call	0x1b2	; 0x1b2 <USART_tx>

	return 0;
 224:	80 e0       	ldi	r24, 0x00	; 0
 226:	90 e0       	ldi	r25, 0x00	; 0
}
 228:	0f 90       	pop	r0
 22a:	0f 90       	pop	r0
 22c:	0f 90       	pop	r0
 22e:	df 91       	pop	r29
 230:	cf 91       	pop	r28
 232:	08 95       	ret

00000234 <main>:
#include "../lib/adc_battery.h"
#include "../lib/avr_usart.h"

volatile uint16_t valor_adc = 0;

int main(){
 234:	cf 93       	push	r28
 236:	df 93       	push	r29
 238:	cd b7       	in	r28, 0x3d	; 61
 23a:	de b7       	in	r29, 0x3e	; 62
 23c:	a5 97       	sbiw	r28, 0x25	; 37
 23e:	0f b6       	in	r0, 0x3f	; 63
 240:	f8 94       	cli
 242:	de bf       	out	0x3e, r29	; 62
 244:	0f be       	out	0x3f, r0	; 63
 246:	cd bf       	out	0x3d, r28	; 61
	uint8_t x = 0;
 248:	19 82       	std	Y+1, r1	; 0x01

	/* Obtem o stream de depuração */
	FILE *debug = get_usart_stream();
 24a:	0e 94 a8 00 	call	0x150	; 0x150 <get_usart_stream>
 24e:	9b 83       	std	Y+3, r25	; 0x03
 250:	8a 83       	std	Y+2, r24	; 0x02

	/* Inicializa hardware da USART */
	USART_Init(B9600);
 252:	8c e8       	ldi	r24, 0x8C	; 140
 254:	91 e0       	ldi	r25, 0x01	; 1
 256:	0e 94 b1 00 	call	0x162	; 0x162 <USART_Init>
	/* Configura timer em modo PWM */
	//timer0_pwm_hardware_init();

	//timer2_pwm_hardware_init();

	sei();
 25a:	78 94       	sei
		//_delay_ms(10);

		//fprintf(debug, "%d\r", valor_adc);

		//fprintf(debug, "%d\n\r", x);
		fprintf(debug,"Teste de debug\n");
 25c:	8a 81       	ldd	r24, Y+2	; 0x02
 25e:	9b 81       	ldd	r25, Y+3	; 0x03
 260:	9c 01       	movw	r18, r24
 262:	4f e0       	ldi	r20, 0x0F	; 15
 264:	50 e0       	ldi	r21, 0x00	; 0
 266:	61 e0       	ldi	r22, 0x01	; 1
 268:	70 e0       	ldi	r23, 0x00	; 0
 26a:	8f e0       	ldi	r24, 0x0F	; 15
 26c:	91 e0       	ldi	r25, 0x01	; 1
 26e:	0e 94 ef 04 	call	0x9de	; 0x9de <fwrite>
				x++;
 272:	89 81       	ldd	r24, Y+1	; 0x01
 274:	8f 5f       	subi	r24, 0xFF	; 255
 276:	89 83       	std	Y+1, r24	; 0x01
 278:	80 e0       	ldi	r24, 0x00	; 0
 27a:	90 e0       	ldi	r25, 0x00	; 0
 27c:	aa e7       	ldi	r26, 0x7A	; 122
 27e:	b4 e4       	ldi	r27, 0x44	; 68
 280:	8c 83       	std	Y+4, r24	; 0x04
 282:	9d 83       	std	Y+5, r25	; 0x05
 284:	ae 83       	std	Y+6, r26	; 0x06
 286:	bf 83       	std	Y+7, r27	; 0x07

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
 288:	20 e0       	ldi	r18, 0x00	; 0
 28a:	38 e4       	ldi	r19, 0x48	; 72
 28c:	4e e6       	ldi	r20, 0x6E	; 110
 28e:	56 e4       	ldi	r21, 0x46	; 70
 290:	6c 81       	ldd	r22, Y+4	; 0x04
 292:	7d 81       	ldd	r23, Y+5	; 0x05
 294:	8e 81       	ldd	r24, Y+6	; 0x06
 296:	9f 81       	ldd	r25, Y+7	; 0x07
 298:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <__mulsf3>
 29c:	6e 8b       	std	Y+22, r22	; 0x16
 29e:	7f 8b       	std	Y+23, r23	; 0x17
 2a0:	88 8f       	std	Y+24, r24	; 0x18
 2a2:	99 8f       	std	Y+25, r25	; 0x19
 2a4:	8e 89       	ldd	r24, Y+22	; 0x16
 2a6:	9f 89       	ldd	r25, Y+23	; 0x17
 2a8:	a8 8d       	ldd	r26, Y+24	; 0x18
 2aa:	b9 8d       	ldd	r27, Y+25	; 0x19
 2ac:	88 87       	std	Y+8, r24	; 0x08
 2ae:	99 87       	std	Y+9, r25	; 0x09
 2b0:	aa 87       	std	Y+10, r26	; 0x0a
 2b2:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
 2b4:	20 e0       	ldi	r18, 0x00	; 0
 2b6:	30 e0       	ldi	r19, 0x00	; 0
 2b8:	40 e8       	ldi	r20, 0x80	; 128
 2ba:	5f e3       	ldi	r21, 0x3F	; 63
 2bc:	68 85       	ldd	r22, Y+8	; 0x08
 2be:	79 85       	ldd	r23, Y+9	; 0x09
 2c0:	8a 85       	ldd	r24, Y+10	; 0x0a
 2c2:	9b 85       	ldd	r25, Y+11	; 0x0b
 2c4:	0e 94 d4 03 	call	0x7a8	; 0x7a8 <__cmpsf2>
 2c8:	88 23       	and	r24, r24
 2ca:	2c f4       	brge	.+10     	; 0x2d6 <main+0xa2>
		__ticks = 1;
 2cc:	81 e0       	ldi	r24, 0x01	; 1
 2ce:	90 e0       	ldi	r25, 0x00	; 0
 2d0:	9d 87       	std	Y+13, r25	; 0x0d
 2d2:	8c 87       	std	Y+12, r24	; 0x0c
 2d4:	54 c0       	rjmp	.+168    	; 0x37e <main+0x14a>
	else if (__tmp > 65535)
 2d6:	20 e0       	ldi	r18, 0x00	; 0
 2d8:	3f ef       	ldi	r19, 0xFF	; 255
 2da:	4f e7       	ldi	r20, 0x7F	; 127
 2dc:	57 e4       	ldi	r21, 0x47	; 71
 2de:	68 85       	ldd	r22, Y+8	; 0x08
 2e0:	79 85       	ldd	r23, Y+9	; 0x09
 2e2:	8a 85       	ldd	r24, Y+10	; 0x0a
 2e4:	9b 85       	ldd	r25, Y+11	; 0x0b
 2e6:	0e 94 55 04 	call	0x8aa	; 0x8aa <__gesf2>
 2ea:	18 16       	cp	r1, r24
 2ec:	d4 f5       	brge	.+116    	; 0x362 <main+0x12e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
 2ee:	20 e0       	ldi	r18, 0x00	; 0
 2f0:	30 e0       	ldi	r19, 0x00	; 0
 2f2:	40 e2       	ldi	r20, 0x20	; 32
 2f4:	51 e4       	ldi	r21, 0x41	; 65
 2f6:	6c 81       	ldd	r22, Y+4	; 0x04
 2f8:	7d 81       	ldd	r23, Y+5	; 0x05
 2fa:	8e 81       	ldd	r24, Y+6	; 0x06
 2fc:	9f 81       	ldd	r25, Y+7	; 0x07
 2fe:	0e 94 5a 04 	call	0x8b4	; 0x8b4 <__mulsf3>
 302:	6a 8f       	std	Y+26, r22	; 0x1a
 304:	7b 8f       	std	Y+27, r23	; 0x1b
 306:	8c 8f       	std	Y+28, r24	; 0x1c
 308:	9d 8f       	std	Y+29, r25	; 0x1d
 30a:	8a 8d       	ldd	r24, Y+26	; 0x1a
 30c:	9b 8d       	ldd	r25, Y+27	; 0x1b
 30e:	ac 8d       	ldd	r26, Y+28	; 0x1c
 310:	bd 8d       	ldd	r27, Y+29	; 0x1d
 312:	8a 8b       	std	Y+18, r24	; 0x12
 314:	9b 8b       	std	Y+19, r25	; 0x13
 316:	ac 8b       	std	Y+20, r26	; 0x14
 318:	bd 8b       	std	Y+21, r27	; 0x15
 31a:	6a 89       	ldd	r22, Y+18	; 0x12
 31c:	7b 89       	ldd	r23, Y+19	; 0x13
 31e:	8c 89       	ldd	r24, Y+20	; 0x14
 320:	9d 89       	ldd	r25, Y+21	; 0x15
 322:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <__fixunssfsi>
 326:	6e 8f       	std	Y+30, r22	; 0x1e
 328:	7f 8f       	std	Y+31, r23	; 0x1f
 32a:	88 a3       	std	Y+32, r24	; 0x20
 32c:	99 a3       	std	Y+33, r25	; 0x21
 32e:	ae 8d       	ldd	r26, Y+30	; 0x1e
 330:	bf 8d       	ldd	r27, Y+31	; 0x1f
 332:	bd 87       	std	Y+13, r27	; 0x0d
 334:	ac 87       	std	Y+12, r26	; 0x0c
		while(__ticks)
 336:	10 c0       	rjmp	.+32     	; 0x358 <main+0x124>
 338:	85 ef       	ldi	r24, 0xF5	; 245
 33a:	95 e0       	ldi	r25, 0x05	; 5
 33c:	9f 87       	std	Y+15, r25	; 0x0f
 33e:	8e 87       	std	Y+14, r24	; 0x0e
		"sbc %B0,__zero_reg__"    "\n\t"
		"brne 1b"
		: "+d" (__count)
	);
#else
	__asm__ volatile (
 340:	8e 85       	ldd	r24, Y+14	; 0x0e
 342:	9f 85       	ldd	r25, Y+15	; 0x0f
 344:	01 97       	sbiw	r24, 0x01	; 1
 346:	f1 f7       	brne	.-4      	; 0x344 <main+0x110>
 348:	9f 87       	std	Y+15, r25	; 0x0f
 34a:	8e 87       	std	Y+14, r24	; 0x0e
		"brne 1b"
		: "=w" (__count)
		: "0" (__count)
	);
#endif /* __AVR_TINY__ */
}
 34c:	00 00       	nop
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
 34e:	8c 85       	ldd	r24, Y+12	; 0x0c
 350:	9d 85       	ldd	r25, Y+13	; 0x0d
 352:	01 97       	sbiw	r24, 0x01	; 1
 354:	9d 87       	std	Y+13, r25	; 0x0d
 356:	8c 87       	std	Y+12, r24	; 0x0c
		while(__ticks)
 358:	8c 85       	ldd	r24, Y+12	; 0x0c
 35a:	9d 85       	ldd	r25, Y+13	; 0x0d
 35c:	89 2b       	or	r24, r25
 35e:	61 f7       	brne	.-40     	; 0x338 <main+0x104>
		}
		return;
 360:	19 c0       	rjmp	.+50     	; 0x394 <main+0x160>
	}
	else
		__ticks = (uint16_t)__tmp;
 362:	68 85       	ldd	r22, Y+8	; 0x08
 364:	79 85       	ldd	r23, Y+9	; 0x09
 366:	8a 85       	ldd	r24, Y+10	; 0x0a
 368:	9b 85       	ldd	r25, Y+11	; 0x0b
 36a:	0e 94 d9 03 	call	0x7b2	; 0x7b2 <__fixunssfsi>
 36e:	6a a3       	std	Y+34, r22	; 0x22
 370:	7b a3       	std	Y+35, r23	; 0x23
 372:	8c a3       	std	Y+36, r24	; 0x24
 374:	9d a3       	std	Y+37, r25	; 0x25
 376:	8a a1       	ldd	r24, Y+34	; 0x22
 378:	9b a1       	ldd	r25, Y+35	; 0x23
 37a:	9d 87       	std	Y+13, r25	; 0x0d
 37c:	8c 87       	std	Y+12, r24	; 0x0c
 37e:	8c 85       	ldd	r24, Y+12	; 0x0c
 380:	9d 85       	ldd	r25, Y+13	; 0x0d
 382:	99 8b       	std	Y+17, r25	; 0x11
 384:	88 8b       	std	Y+16, r24	; 0x10
	__asm__ volatile (
 386:	88 89       	ldd	r24, Y+16	; 0x10
 388:	99 89       	ldd	r25, Y+17	; 0x11
 38a:	01 97       	sbiw	r24, 0x01	; 1
 38c:	f1 f7       	brne	.-4      	; 0x38a <main+0x156>
 38e:	99 8b       	std	Y+17, r25	; 0x11
 390:	88 8b       	std	Y+16, r24	; 0x10
}
 392:	00 00       	nop
		fprintf(debug,"Teste de debug\n");
 394:	63 cf       	rjmp	.-314    	; 0x25c <main+0x28>

00000396 <set_dutty>:
#include "../lib/bits.h"
#include "../lib/avr_timer.h"
#include "../lib/avr_gpio.h"
#include "../lib/motor.h"

void set_dutty(uint8_t dutty){
 396:	cf 93       	push	r28
 398:	df 93       	push	r29
 39a:	0f 92       	push	r0
 39c:	cd b7       	in	r28, 0x3d	; 61
 39e:	de b7       	in	r29, 0x3e	; 62
 3a0:	89 83       	std	Y+1, r24	; 0x01

	if (dutty <= TIMER_0->OCRA)
 3a2:	84 e4       	ldi	r24, 0x44	; 68
 3a4:	90 e0       	ldi	r25, 0x00	; 0
 3a6:	fc 01       	movw	r30, r24
 3a8:	83 81       	ldd	r24, Z+3	; 0x03
 3aa:	99 81       	ldd	r25, Y+1	; 0x01
 3ac:	89 17       	cp	r24, r25
 3ae:	28 f0       	brcs	.+10     	; 0x3ba <set_dutty+0x24>
		TIMER_0->OCRB = dutty;
 3b0:	84 e4       	ldi	r24, 0x44	; 68
 3b2:	90 e0       	ldi	r25, 0x00	; 0
 3b4:	29 81       	ldd	r18, Y+1	; 0x01
 3b6:	fc 01       	movw	r30, r24
 3b8:	24 83       	std	Z+4, r18	; 0x04

	if (dutty <= TIMER_2->OCRA)
 3ba:	80 eb       	ldi	r24, 0xB0	; 176
 3bc:	90 e0       	ldi	r25, 0x00	; 0
 3be:	fc 01       	movw	r30, r24
 3c0:	83 81       	ldd	r24, Z+3	; 0x03
 3c2:	99 81       	ldd	r25, Y+1	; 0x01
 3c4:	89 17       	cp	r24, r25
 3c6:	28 f0       	brcs	.+10     	; 0x3d2 <set_dutty+0x3c>
			TIMER_2->OCRB = dutty;
 3c8:	80 eb       	ldi	r24, 0xB0	; 176
 3ca:	90 e0       	ldi	r25, 0x00	; 0
 3cc:	29 81       	ldd	r18, Y+1	; 0x01
 3ce:	fc 01       	movw	r30, r24
 3d0:	24 83       	std	Z+4, r18	; 0x04
}
 3d2:	00 00       	nop
 3d4:	0f 90       	pop	r0
 3d6:	df 91       	pop	r29
 3d8:	cf 91       	pop	r28
 3da:	08 95       	ret

000003dc <timer0_pwm_hardware_init>:

void timer0_pwm_hardware_init(){
 3dc:	cf 93       	push	r28
 3de:	df 93       	push	r29
 3e0:	cd b7       	in	r28, 0x3d	; 61
 3e2:	de b7       	in	r29, 0x3e	; 62

	/* PD5: pino OC0B como saida */
	GPIO_D->DDR |= SET(PD5);
 3e4:	89 e2       	ldi	r24, 0x29	; 41
 3e6:	90 e0       	ldi	r25, 0x00	; 0
 3e8:	fc 01       	movw	r30, r24
 3ea:	21 81       	ldd	r18, Z+1	; 0x01
 3ec:	89 e2       	ldi	r24, 0x29	; 41
 3ee:	90 e0       	ldi	r25, 0x00	; 0
 3f0:	20 62       	ori	r18, 0x20	; 32
 3f2:	fc 01       	movw	r30, r24
 3f4:	21 83       	std	Z+1, r18	; 0x01
	    0       1       Reserved
	    1       0       Clear OC0B on Compare Match, set OC0B at BOTTOM (non-inverting mode)
	    1       1       Set OC0B on Compare Match, clear OC0B at BOTTOM (inverting mode).*/

	/* WGM02, WGM01 WGM00 setados: modo PWM rápido com TOP em OCRA */
	TIMER_0->TCCRA = SET(WGM01) | SET(WGM00) | SET(COM0B1);
 3f6:	84 e4       	ldi	r24, 0x44	; 68
 3f8:	90 e0       	ldi	r25, 0x00	; 0
 3fa:	23 e2       	ldi	r18, 0x23	; 35
 3fc:	fc 01       	movw	r30, r24
 3fe:	20 83       	st	Z, r18
	TIMER_0->TCCRB = SET(WGM02) | SET(CS01) | SET(CS00);
 400:	84 e4       	ldi	r24, 0x44	; 68
 402:	90 e0       	ldi	r25, 0x00	; 0
 404:	2b e0       	ldi	r18, 0x0B	; 11
 406:	fc 01       	movw	r30, r24
 408:	21 83       	std	Z+1, r18	; 0x01
	//CLR(CS02)

	/* OCRA define frequência do PWM */
	TIMER_0->OCRA = 124;
 40a:	84 e4       	ldi	r24, 0x44	; 68
 40c:	90 e0       	ldi	r25, 0x00	; 0
 40e:	2c e7       	ldi	r18, 0x7C	; 124
 410:	fc 01       	movw	r30, r24
 412:	23 83       	std	Z+3, r18	; 0x03

	/* OCRB define razão cíclica:  OCRB / OCRA */
	TIMER_0->OCRB = 150;
 414:	84 e4       	ldi	r24, 0x44	; 68
 416:	90 e0       	ldi	r25, 0x00	; 0
 418:	26 e9       	ldi	r18, 0x96	; 150
 41a:	fc 01       	movw	r30, r24
 41c:	24 83       	std	Z+4, r18	; 0x04
}
 41e:	00 00       	nop
 420:	df 91       	pop	r29
 422:	cf 91       	pop	r28
 424:	08 95       	ret

00000426 <timer2_pwm_hardware_init>:

void timer2_pwm_hardware_init(){
 426:	cf 93       	push	r28
 428:	df 93       	push	r29
 42a:	cd b7       	in	r28, 0x3d	; 61
 42c:	de b7       	in	r29, 0x3e	; 62

	/* PD3: pino OC2B como saida */
	GPIO_D->DDR |= SET(PD3);
 42e:	89 e2       	ldi	r24, 0x29	; 41
 430:	90 e0       	ldi	r25, 0x00	; 0
 432:	fc 01       	movw	r30, r24
 434:	21 81       	ldd	r18, Z+1	; 0x01
 436:	89 e2       	ldi	r24, 0x29	; 41
 438:	90 e0       	ldi	r25, 0x00	; 0
 43a:	28 60       	ori	r18, 0x08	; 8
 43c:	fc 01       	movw	r30, r24
 43e:	21 83       	std	Z+1, r18	; 0x01
	    0       1       Reserved
	    1       0       Clear OC0B on Compare Match, set OC0B at BOTTOM (non-inverting mode)
	    1       1       Set OC0B on Compare Match, clear OC0B at BOTTOM (inverting mode).*/

	/* WGM02, WGM01 WGM00 setados: modo PWM rápido com TOP em OCRA */
	TIMER_2->TCCRA = SET(WGM21) | SET(WGM20) | SET(COM2B1);
 440:	80 eb       	ldi	r24, 0xB0	; 176
 442:	90 e0       	ldi	r25, 0x00	; 0
 444:	23 e2       	ldi	r18, 0x23	; 35
 446:	fc 01       	movw	r30, r24
 448:	20 83       	st	Z, r18
	TIMER_2->TCCRB = SET(WGM22) | SET(CS21) | SET(CS20);
 44a:	80 eb       	ldi	r24, 0xB0	; 176
 44c:	90 e0       	ldi	r25, 0x00	; 0
 44e:	2b e0       	ldi	r18, 0x0B	; 11
 450:	fc 01       	movw	r30, r24
 452:	21 83       	std	Z+1, r18	; 0x01
	//CLR(CS22)
	/* OCRA define frequência do PWM */
	TIMER_2->OCRA = 249;
 454:	80 eb       	ldi	r24, 0xB0	; 176
 456:	90 e0       	ldi	r25, 0x00	; 0
 458:	29 ef       	ldi	r18, 0xF9	; 249
 45a:	fc 01       	movw	r30, r24
 45c:	23 83       	std	Z+3, r18	; 0x03

	/* OCRB define razão cíclica:  OCRB / OCRA */
	TIMER_2->OCRB = 150;
 45e:	80 eb       	ldi	r24, 0xB0	; 176
 460:	90 e0       	ldi	r25, 0x00	; 0
 462:	26 e9       	ldi	r18, 0x96	; 150
 464:	fc 01       	movw	r30, r24
 466:	24 83       	std	Z+4, r18	; 0x04
}
 468:	00 00       	nop
 46a:	df 91       	pop	r29
 46c:	cf 91       	pop	r28
 46e:	08 95       	ret

00000470 <TWI_Master_Initialise>:
/****************************************************************************
Call this function to set up the TWI master to its initial standby state.
Remember to enable interrupts from the main application after initializing the TWI.
****************************************************************************/
void TWI_Master_Initialise(void)
{
 470:	cf 93       	push	r28
 472:	df 93       	push	r29
 474:	cd b7       	in	r28, 0x3d	; 61
 476:	de b7       	in	r29, 0x3e	; 62
  TWBR = TWI_TWBR;                                  // Set bit rate register (Baud rate). Defined in header file.Driver presumes prescaler to be 00.                                
 478:	88 eb       	ldi	r24, 0xB8	; 184
 47a:	90 e0       	ldi	r25, 0x00	; 0
 47c:	24 e8       	ldi	r18, 0x84	; 132
 47e:	fc 01       	movw	r30, r24
 480:	20 83       	st	Z, r18
  TWDR = 0xFF;                                      // Default content = SDA released.
 482:	8b eb       	ldi	r24, 0xBB	; 187
 484:	90 e0       	ldi	r25, 0x00	; 0
 486:	2f ef       	ldi	r18, 0xFF	; 255
 488:	fc 01       	movw	r30, r24
 48a:	20 83       	st	Z, r18
  TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins.
 48c:	8c eb       	ldi	r24, 0xBC	; 188
 48e:	90 e0       	ldi	r25, 0x00	; 0
 490:	24 e0       	ldi	r18, 0x04	; 4
 492:	fc 01       	movw	r30, r24
 494:	20 83       	st	Z, r18
         (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt.
         (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests.
         (0<<TWWC);                                 //
}    
 496:	00 00       	nop
 498:	df 91       	pop	r29
 49a:	cf 91       	pop	r28
 49c:	08 95       	ret

0000049e <TWI_Transceiver_Busy>:
    
/****************************************************************************
Call this function to test if the TWI_ISR is busy transmitting.
****************************************************************************/
unsigned char TWI_Transceiver_Busy( void )
{
 49e:	cf 93       	push	r28
 4a0:	df 93       	push	r29
 4a2:	cd b7       	in	r28, 0x3d	; 61
 4a4:	de b7       	in	r29, 0x3e	; 62
  return ( TWCR & (1<<TWIE) );                  // IF TWI Interrupt is enabled then the Transceiver is busy
 4a6:	8c eb       	ldi	r24, 0xBC	; 188
 4a8:	90 e0       	ldi	r25, 0x00	; 0
 4aa:	fc 01       	movw	r30, r24
 4ac:	80 81       	ld	r24, Z
 4ae:	81 70       	andi	r24, 0x01	; 1
}
 4b0:	df 91       	pop	r29
 4b2:	cf 91       	pop	r28
 4b4:	08 95       	ret

000004b6 <TWI_Get_State_Info>:
Call this function to fetch the state information of the previous operation. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation. If there was an error, then the function 
will return the TWI State code. 
****************************************************************************/
unsigned char TWI_Get_State_Info( void )
{
 4b6:	cf 93       	push	r28
 4b8:	df 93       	push	r29
 4ba:	cd b7       	in	r28, 0x3d	; 61
 4bc:	de b7       	in	r29, 0x3e	; 62
  while ( TWI_Transceiver_Busy() );             // Wait until TWI has completed the transmission.
 4be:	00 00       	nop
 4c0:	0e 94 4f 02 	call	0x49e	; 0x49e <TWI_Transceiver_Busy>
 4c4:	88 23       	and	r24, r24
 4c6:	e1 f7       	brne	.-8      	; 0x4c0 <TWI_Get_State_Info+0xa>
  return ( TWI_state );                         // Return error state.
 4c8:	80 91 0e 01 	lds	r24, 0x010E	; 0x80010e <TWI_state>
}
 4cc:	df 91       	pop	r29
 4ce:	cf 91       	pop	r28
 4d0:	08 95       	ret

000004d2 <TWI_Start_Transceiver_With_Data>:
from the slave. Also include how many bytes that should be sent/read including the address byte.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver_With_Data( unsigned char *msg, unsigned char msgSize )
{
 4d2:	cf 93       	push	r28
 4d4:	df 93       	push	r29
 4d6:	00 d0       	rcall	.+0      	; 0x4d8 <TWI_Start_Transceiver_With_Data+0x6>
 4d8:	00 d0       	rcall	.+0      	; 0x4da <TWI_Start_Transceiver_With_Data+0x8>
 4da:	cd b7       	in	r28, 0x3d	; 61
 4dc:	de b7       	in	r29, 0x3e	; 62
 4de:	9b 83       	std	Y+3, r25	; 0x03
 4e0:	8a 83       	std	Y+2, r24	; 0x02
 4e2:	6c 83       	std	Y+4, r22	; 0x04
  unsigned char temp;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 4e4:	00 00       	nop
 4e6:	0e 94 4f 02 	call	0x49e	; 0x49e <TWI_Transceiver_Busy>
 4ea:	88 23       	and	r24, r24
 4ec:	e1 f7       	brne	.-8      	; 0x4e6 <TWI_Start_Transceiver_With_Data+0x14>

  TWI_msgSize = msgSize;                        // Number of data to transmit.
 4ee:	8c 81       	ldd	r24, Y+4	; 0x04
 4f0:	80 93 26 01 	sts	0x0126, r24	; 0x800126 <TWI_msgSize>
  TWI_buf[0]  = msg[0];                         // Store slave address with R/W setting.
 4f4:	8a 81       	ldd	r24, Y+2	; 0x02
 4f6:	9b 81       	ldd	r25, Y+3	; 0x03
 4f8:	fc 01       	movw	r30, r24
 4fa:	80 81       	ld	r24, Z
 4fc:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <TWI_buf>
  if (!( msg[0] & (TRUE<<TWI_READ_BIT) ))       // If it is a write operation, then also copy data.
 500:	8a 81       	ldd	r24, Y+2	; 0x02
 502:	9b 81       	ldd	r25, Y+3	; 0x03
 504:	fc 01       	movw	r30, r24
 506:	80 81       	ld	r24, Z
 508:	88 2f       	mov	r24, r24
 50a:	90 e0       	ldi	r25, 0x00	; 0
 50c:	81 70       	andi	r24, 0x01	; 1
 50e:	99 27       	eor	r25, r25
 510:	89 2b       	or	r24, r25
 512:	d1 f4       	brne	.+52     	; 0x548 <TWI_Start_Transceiver_With_Data+0x76>
  {
    for ( temp = 1; temp < msgSize; temp++ )
 514:	81 e0       	ldi	r24, 0x01	; 1
 516:	89 83       	std	Y+1, r24	; 0x01
 518:	13 c0       	rjmp	.+38     	; 0x540 <TWI_Start_Transceiver_With_Data+0x6e>
      TWI_buf[ temp ] = msg[ temp ];
 51a:	89 81       	ldd	r24, Y+1	; 0x01
 51c:	88 2f       	mov	r24, r24
 51e:	90 e0       	ldi	r25, 0x00	; 0
 520:	2a 81       	ldd	r18, Y+2	; 0x02
 522:	3b 81       	ldd	r19, Y+3	; 0x03
 524:	28 0f       	add	r18, r24
 526:	39 1f       	adc	r19, r25
 528:	89 81       	ldd	r24, Y+1	; 0x01
 52a:	88 2f       	mov	r24, r24
 52c:	90 e0       	ldi	r25, 0x00	; 0
 52e:	f9 01       	movw	r30, r18
 530:	20 81       	ld	r18, Z
 532:	8e 5d       	subi	r24, 0xDE	; 222
 534:	9e 4f       	sbci	r25, 0xFE	; 254
 536:	fc 01       	movw	r30, r24
 538:	20 83       	st	Z, r18
    for ( temp = 1; temp < msgSize; temp++ )
 53a:	89 81       	ldd	r24, Y+1	; 0x01
 53c:	8f 5f       	subi	r24, 0xFF	; 255
 53e:	89 83       	std	Y+1, r24	; 0x01
 540:	99 81       	ldd	r25, Y+1	; 0x01
 542:	8c 81       	ldd	r24, Y+4	; 0x04
 544:	98 17       	cp	r25, r24
 546:	48 f3       	brcs	.-46     	; 0x51a <TWI_Start_Transceiver_With_Data+0x48>
  }
  TWI_statusReg.all = 0;      
 548:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <TWI_statusReg>
  TWI_state         = TWI_NO_STATE ;
 54c:	88 ef       	ldi	r24, 0xF8	; 248
 54e:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <TWI_state>
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 552:	8c eb       	ldi	r24, 0xBC	; 188
 554:	90 e0       	ldi	r25, 0x00	; 0
 556:	25 ea       	ldi	r18, 0xA5	; 165
 558:	fc 01       	movw	r30, r24
 55a:	20 83       	st	Z, r18
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);
}
 55c:	00 00       	nop
 55e:	0f 90       	pop	r0
 560:	0f 90       	pop	r0
 562:	0f 90       	pop	r0
 564:	0f 90       	pop	r0
 566:	df 91       	pop	r29
 568:	cf 91       	pop	r28
 56a:	08 95       	ret

0000056c <TWI_Start_Transceiver>:
Call this function to resend the last message. The driver will reuse the data previously put in the transceiver buffers.
The function will hold execution (loop) until the TWI_ISR has completed with the previous operation,
then initialize the next operation and return.
****************************************************************************/
void TWI_Start_Transceiver( void )
{
 56c:	cf 93       	push	r28
 56e:	df 93       	push	r29
 570:	cd b7       	in	r28, 0x3d	; 61
 572:	de b7       	in	r29, 0x3e	; 62
  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 574:	00 00       	nop
 576:	0e 94 4f 02 	call	0x49e	; 0x49e <TWI_Transceiver_Busy>
 57a:	88 23       	and	r24, r24
 57c:	e1 f7       	brne	.-8      	; 0x576 <TWI_Start_Transceiver+0xa>
  TWI_statusReg.all = 0;      
 57e:	10 92 27 01 	sts	0x0127, r1	; 0x800127 <TWI_statusReg>
  TWI_state         = TWI_NO_STATE ;
 582:	88 ef       	ldi	r24, 0xF8	; 248
 584:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <TWI_state>
  TWCR = (1<<TWEN)|                             // TWI Interface enabled.
 588:	8c eb       	ldi	r24, 0xBC	; 188
 58a:	90 e0       	ldi	r25, 0x00	; 0
 58c:	25 ea       	ldi	r18, 0xA5	; 165
 58e:	fc 01       	movw	r30, r24
 590:	20 83       	st	Z, r18
         (1<<TWIE)|(1<<TWINT)|                  // Enable TWI Interrupt and clear the flag.
         (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|       // Initiate a START condition.
         (0<<TWWC);                             //
}
 592:	00 00       	nop
 594:	df 91       	pop	r29
 596:	cf 91       	pop	r28
 598:	08 95       	ret

0000059a <TWI_Get_Data_From_Transceiver>:
requested (including the address field) in the function call. The function will hold execution (loop)
until the TWI_ISR has completed with the previous operation, before reading out the data and returning.
If there was an error in the previous transmission the function will return the TWI error code.
****************************************************************************/
unsigned char TWI_Get_Data_From_Transceiver( unsigned char *msg, unsigned char msgSize )
{
 59a:	cf 93       	push	r28
 59c:	df 93       	push	r29
 59e:	00 d0       	rcall	.+0      	; 0x5a0 <TWI_Get_Data_From_Transceiver+0x6>
 5a0:	00 d0       	rcall	.+0      	; 0x5a2 <TWI_Get_Data_From_Transceiver+0x8>
 5a2:	cd b7       	in	r28, 0x3d	; 61
 5a4:	de b7       	in	r29, 0x3e	; 62
 5a6:	9b 83       	std	Y+3, r25	; 0x03
 5a8:	8a 83       	std	Y+2, r24	; 0x02
 5aa:	6c 83       	std	Y+4, r22	; 0x04
  unsigned char i;

  while ( TWI_Transceiver_Busy() );             // Wait until TWI is ready for next transmission.
 5ac:	00 00       	nop
 5ae:	0e 94 4f 02 	call	0x49e	; 0x49e <TWI_Transceiver_Busy>
 5b2:	88 23       	and	r24, r24
 5b4:	e1 f7       	brne	.-8      	; 0x5ae <TWI_Get_Data_From_Transceiver+0x14>

  if( TWI_statusReg.lastTransOK )               // Last transmission competed successfully.              
 5b6:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <TWI_statusReg>
 5ba:	81 70       	andi	r24, 0x01	; 1
 5bc:	88 23       	and	r24, r24
 5be:	c9 f0       	breq	.+50     	; 0x5f2 <TWI_Get_Data_From_Transceiver+0x58>
  {                                             
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 5c0:	19 82       	std	Y+1, r1	; 0x01
 5c2:	13 c0       	rjmp	.+38     	; 0x5ea <TWI_Get_Data_From_Transceiver+0x50>
    {
      msg[ i ] = TWI_buf[ i ];
 5c4:	89 81       	ldd	r24, Y+1	; 0x01
 5c6:	28 2f       	mov	r18, r24
 5c8:	30 e0       	ldi	r19, 0x00	; 0
 5ca:	89 81       	ldd	r24, Y+1	; 0x01
 5cc:	88 2f       	mov	r24, r24
 5ce:	90 e0       	ldi	r25, 0x00	; 0
 5d0:	4a 81       	ldd	r20, Y+2	; 0x02
 5d2:	5b 81       	ldd	r21, Y+3	; 0x03
 5d4:	84 0f       	add	r24, r20
 5d6:	95 1f       	adc	r25, r21
 5d8:	2e 5d       	subi	r18, 0xDE	; 222
 5da:	3e 4f       	sbci	r19, 0xFE	; 254
 5dc:	f9 01       	movw	r30, r18
 5de:	20 81       	ld	r18, Z
 5e0:	fc 01       	movw	r30, r24
 5e2:	20 83       	st	Z, r18
    for ( i=0; i<msgSize; i++ )                 // Copy data from Transceiver buffer.
 5e4:	89 81       	ldd	r24, Y+1	; 0x01
 5e6:	8f 5f       	subi	r24, 0xFF	; 255
 5e8:	89 83       	std	Y+1, r24	; 0x01
 5ea:	99 81       	ldd	r25, Y+1	; 0x01
 5ec:	8c 81       	ldd	r24, Y+4	; 0x04
 5ee:	98 17       	cp	r25, r24
 5f0:	48 f3       	brcs	.-46     	; 0x5c4 <TWI_Get_Data_From_Transceiver+0x2a>
    }
  }
  return( TWI_statusReg.lastTransOK );                                   
 5f2:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <TWI_statusReg>
 5f6:	81 70       	andi	r24, 0x01	; 1
}
 5f8:	0f 90       	pop	r0
 5fa:	0f 90       	pop	r0
 5fc:	0f 90       	pop	r0
 5fe:	0f 90       	pop	r0
 600:	df 91       	pop	r29
 602:	cf 91       	pop	r28
 604:	08 95       	ret

00000606 <__vector_24>:
This function is the Interrupt Service Routine (ISR), and called when the TWI interrupt is triggered;
that is whenever a TWI event has occurred. This function should not be called directly from the main
application.
****************************************************************************/
ISR(TWI_vect)
{
 606:	1f 92       	push	r1
 608:	0f 92       	push	r0
 60a:	0f b6       	in	r0, 0x3f	; 63
 60c:	0f 92       	push	r0
 60e:	11 24       	eor	r1, r1
 610:	2f 93       	push	r18
 612:	3f 93       	push	r19
 614:	8f 93       	push	r24
 616:	9f 93       	push	r25
 618:	ef 93       	push	r30
 61a:	ff 93       	push	r31
 61c:	cf 93       	push	r28
 61e:	df 93       	push	r29
 620:	cd b7       	in	r28, 0x3d	; 61
 622:	de b7       	in	r29, 0x3e	; 62
  static unsigned char TWI_bufPtr;
  
  switch (TWSR)
 624:	89 eb       	ldi	r24, 0xB9	; 185
 626:	90 e0       	ldi	r25, 0x00	; 0
 628:	fc 01       	movw	r30, r24
 62a:	80 81       	ld	r24, Z
 62c:	88 2f       	mov	r24, r24
 62e:	90 e0       	ldi	r25, 0x00	; 0
 630:	88 35       	cpi	r24, 0x58	; 88
 632:	91 05       	cpc	r25, r1
 634:	09 f4       	brne	.+2      	; 0x638 <__vector_24+0x32>
 636:	81 c0       	rjmp	.+258    	; 0x73a <__vector_24+0x134>
 638:	89 35       	cpi	r24, 0x59	; 89
 63a:	91 05       	cpc	r25, r1
 63c:	0c f0       	brlt	.+2      	; 0x640 <__vector_24+0x3a>
 63e:	9a c0       	rjmp	.+308    	; 0x774 <__vector_24+0x16e>
 640:	80 35       	cpi	r24, 0x50	; 80
 642:	91 05       	cpc	r25, r1
 644:	09 f4       	brne	.+2      	; 0x648 <__vector_24+0x42>
 646:	51 c0       	rjmp	.+162    	; 0x6ea <__vector_24+0xe4>
 648:	81 35       	cpi	r24, 0x51	; 81
 64a:	91 05       	cpc	r25, r1
 64c:	0c f0       	brlt	.+2      	; 0x650 <__vector_24+0x4a>
 64e:	92 c0       	rjmp	.+292    	; 0x774 <__vector_24+0x16e>
 650:	80 34       	cpi	r24, 0x40	; 64
 652:	91 05       	cpc	r25, r1
 654:	09 f4       	brne	.+2      	; 0x658 <__vector_24+0x52>
 656:	59 c0       	rjmp	.+178    	; 0x70a <__vector_24+0x104>
 658:	81 34       	cpi	r24, 0x41	; 65
 65a:	91 05       	cpc	r25, r1
 65c:	0c f0       	brlt	.+2      	; 0x660 <__vector_24+0x5a>
 65e:	8a c0       	rjmp	.+276    	; 0x774 <__vector_24+0x16e>
 660:	88 33       	cpi	r24, 0x38	; 56
 662:	91 05       	cpc	r25, r1
 664:	09 f4       	brne	.+2      	; 0x668 <__vector_24+0x62>
 666:	80 c0       	rjmp	.+256    	; 0x768 <__vector_24+0x162>
 668:	89 33       	cpi	r24, 0x39	; 57
 66a:	91 05       	cpc	r25, r1
 66c:	0c f0       	brlt	.+2      	; 0x670 <__vector_24+0x6a>
 66e:	82 c0       	rjmp	.+260    	; 0x774 <__vector_24+0x16e>
 670:	88 32       	cpi	r24, 0x28	; 40
 672:	91 05       	cpc	r25, r1
 674:	99 f0       	breq	.+38     	; 0x69c <__vector_24+0x96>
 676:	89 32       	cpi	r24, 0x29	; 41
 678:	91 05       	cpc	r25, r1
 67a:	0c f0       	brlt	.+2      	; 0x67e <__vector_24+0x78>
 67c:	7b c0       	rjmp	.+246    	; 0x774 <__vector_24+0x16e>
 67e:	88 31       	cpi	r24, 0x18	; 24
 680:	91 05       	cpc	r25, r1
 682:	61 f0       	breq	.+24     	; 0x69c <__vector_24+0x96>
 684:	89 31       	cpi	r24, 0x19	; 25
 686:	91 05       	cpc	r25, r1
 688:	0c f0       	brlt	.+2      	; 0x68c <__vector_24+0x86>
 68a:	74 c0       	rjmp	.+232    	; 0x774 <__vector_24+0x16e>
 68c:	88 30       	cpi	r24, 0x08	; 8
 68e:	91 05       	cpc	r25, r1
 690:	19 f0       	breq	.+6      	; 0x698 <__vector_24+0x92>
 692:	40 97       	sbiw	r24, 0x10	; 16
 694:	09 f0       	breq	.+2      	; 0x698 <__vector_24+0x92>
 696:	6e c0       	rjmp	.+220    	; 0x774 <__vector_24+0x16e>
  {
    case TWI_START:             // START has been transmitted  
    case TWI_REP_START:         // Repeated START has been transmitted
      TWI_bufPtr = 0;                                     // Set buffer pointer to the TWI Address location
 698:	10 92 28 01 	sts	0x0128, r1	; 0x800128 <TWI_bufPtr.1563>
    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
      if (TWI_bufPtr < TWI_msgSize)
 69c:	90 91 28 01 	lds	r25, 0x0128	; 0x800128 <TWI_bufPtr.1563>
 6a0:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <TWI_msgSize>
 6a4:	98 17       	cp	r25, r24
 6a6:	b0 f4       	brcc	.+44     	; 0x6d4 <__vector_24+0xce>
      {
        TWDR = TWI_buf[TWI_bufPtr++];
 6a8:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <TWI_bufPtr.1563>
 6ac:	91 e0       	ldi	r25, 0x01	; 1
 6ae:	98 0f       	add	r25, r24
 6b0:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <TWI_bufPtr.1563>
 6b4:	28 2f       	mov	r18, r24
 6b6:	30 e0       	ldi	r19, 0x00	; 0
 6b8:	8b eb       	ldi	r24, 0xBB	; 187
 6ba:	90 e0       	ldi	r25, 0x00	; 0
 6bc:	2e 5d       	subi	r18, 0xDE	; 222
 6be:	3e 4f       	sbci	r19, 0xFE	; 254
 6c0:	f9 01       	movw	r30, r18
 6c2:	20 81       	ld	r18, Z
 6c4:	fc 01       	movw	r30, r24
 6c6:	20 83       	st	Z, r18
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 6c8:	8c eb       	ldi	r24, 0xBC	; 188
 6ca:	90 e0       	ldi	r25, 0x00	; 0
 6cc:	25 e8       	ldi	r18, 0x85	; 133
 6ce:	fc 01       	movw	r30, r24
 6d0:	20 83       	st	Z, r18
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
               (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
               (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
               (0<<TWWC);                                 //
      }
      break;
 6d2:	5c c0       	rjmp	.+184    	; 0x78c <__vector_24+0x186>
        TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 6d4:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <TWI_statusReg>
 6d8:	81 60       	ori	r24, 0x01	; 1
 6da:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <TWI_statusReg>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 6de:	8c eb       	ldi	r24, 0xBC	; 188
 6e0:	90 e0       	ldi	r25, 0x00	; 0
 6e2:	24 e9       	ldi	r18, 0x94	; 148
 6e4:	fc 01       	movw	r30, r24
 6e6:	20 83       	st	Z, r18
      break;
 6e8:	51 c0       	rjmp	.+162    	; 0x78c <__vector_24+0x186>
    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
      TWI_buf[TWI_bufPtr++] = TWDR;
 6ea:	2b eb       	ldi	r18, 0xBB	; 187
 6ec:	30 e0       	ldi	r19, 0x00	; 0
 6ee:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <TWI_bufPtr.1563>
 6f2:	91 e0       	ldi	r25, 0x01	; 1
 6f4:	98 0f       	add	r25, r24
 6f6:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <TWI_bufPtr.1563>
 6fa:	88 2f       	mov	r24, r24
 6fc:	90 e0       	ldi	r25, 0x00	; 0
 6fe:	f9 01       	movw	r30, r18
 700:	20 81       	ld	r18, Z
 702:	8e 5d       	subi	r24, 0xDE	; 222
 704:	9e 4f       	sbci	r25, 0xFE	; 254
 706:	fc 01       	movw	r30, r24
 708:	20 83       	st	Z, r18
    case TWI_MRX_ADR_ACK:       // SLA+R has been transmitted and ACK received
      if (TWI_bufPtr < (TWI_msgSize-1) )                  // Detect the last byte to NACK it.
 70a:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <TWI_bufPtr.1563>
 70e:	28 2f       	mov	r18, r24
 710:	30 e0       	ldi	r19, 0x00	; 0
 712:	80 91 26 01 	lds	r24, 0x0126	; 0x800126 <TWI_msgSize>
 716:	88 2f       	mov	r24, r24
 718:	90 e0       	ldi	r25, 0x00	; 0
 71a:	01 97       	sbiw	r24, 0x01	; 1
 71c:	28 17       	cp	r18, r24
 71e:	39 07       	cpc	r19, r25
 720:	34 f4       	brge	.+12     	; 0x72e <__vector_24+0x128>
      {
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 722:	8c eb       	ldi	r24, 0xBC	; 188
 724:	90 e0       	ldi	r25, 0x00	; 0
 726:	25 ec       	ldi	r18, 0xC5	; 197
 728:	fc 01       	movw	r30, r24
 72a:	20 83       	st	Z, r18
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
               (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag to read next byte
               (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // Send NACK after reception
               (0<<TWWC);                                 // 
      }    
      break; 
 72c:	2f c0       	rjmp	.+94     	; 0x78c <__vector_24+0x186>
        TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 72e:	8c eb       	ldi	r24, 0xBC	; 188
 730:	90 e0       	ldi	r25, 0x00	; 0
 732:	25 e8       	ldi	r18, 0x85	; 133
 734:	fc 01       	movw	r30, r24
 736:	20 83       	st	Z, r18
      break; 
 738:	29 c0       	rjmp	.+82     	; 0x78c <__vector_24+0x186>
    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
      TWI_buf[TWI_bufPtr] = TWDR;
 73a:	2b eb       	ldi	r18, 0xBB	; 187
 73c:	30 e0       	ldi	r19, 0x00	; 0
 73e:	80 91 28 01 	lds	r24, 0x0128	; 0x800128 <TWI_bufPtr.1563>
 742:	88 2f       	mov	r24, r24
 744:	90 e0       	ldi	r25, 0x00	; 0
 746:	f9 01       	movw	r30, r18
 748:	20 81       	ld	r18, Z
 74a:	8e 5d       	subi	r24, 0xDE	; 222
 74c:	9e 4f       	sbci	r25, 0xFE	; 254
 74e:	fc 01       	movw	r30, r24
 750:	20 83       	st	Z, r18
      TWI_statusReg.lastTransOK = TRUE;                 // Set status bits to completed successfully. 
 752:	80 91 27 01 	lds	r24, 0x0127	; 0x800127 <TWI_statusReg>
 756:	81 60       	ori	r24, 0x01	; 1
 758:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <TWI_statusReg>
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 75c:	8c eb       	ldi	r24, 0xBC	; 188
 75e:	90 e0       	ldi	r25, 0x00	; 0
 760:	24 e9       	ldi	r18, 0x94	; 148
 762:	fc 01       	movw	r30, r24
 764:	20 83       	st	Z, r18
             (0<<TWIE)|(1<<TWINT)|                      // Disable TWI Interrupt and clear the flag
             (0<<TWEA)|(0<<TWSTA)|(1<<TWSTO)|           // Initiate a STOP condition.
             (0<<TWWC);                                 //
      break;      
 766:	12 c0       	rjmp	.+36     	; 0x78c <__vector_24+0x186>
    case TWI_ARB_LOST:          // Arbitration lost
      TWCR = (1<<TWEN)|                                 // TWI Interface enabled
 768:	8c eb       	ldi	r24, 0xBC	; 188
 76a:	90 e0       	ldi	r25, 0x00	; 0
 76c:	25 ea       	ldi	r18, 0xA5	; 165
 76e:	fc 01       	movw	r30, r24
 770:	20 83       	st	Z, r18
             (1<<TWIE)|(1<<TWINT)|                      // Enable TWI Interrupt and clear the flag
             (0<<TWEA)|(1<<TWSTA)|(0<<TWSTO)|           // Initiate a (RE)START condition.
             (0<<TWWC);                                 //
      break;
 772:	0c c0       	rjmp	.+24     	; 0x78c <__vector_24+0x186>
    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received    
    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
    default:     
      TWI_state = TWSR;                                 // Store TWSR and automatically sets clears noErrors bit.
 774:	89 eb       	ldi	r24, 0xB9	; 185
 776:	90 e0       	ldi	r25, 0x00	; 0
 778:	fc 01       	movw	r30, r24
 77a:	80 81       	ld	r24, Z
 77c:	80 93 0e 01 	sts	0x010E, r24	; 0x80010e <TWI_state>
                                                        // Reset TWI Interface
      TWCR = (1<<TWEN)|                                 // Enable TWI-interface and release TWI pins
 780:	8c eb       	ldi	r24, 0xBC	; 188
 782:	90 e0       	ldi	r25, 0x00	; 0
 784:	24 e0       	ldi	r18, 0x04	; 4
 786:	fc 01       	movw	r30, r24
 788:	20 83       	st	Z, r18
             (0<<TWIE)|(0<<TWINT)|                      // Disable Interrupt
             (0<<TWEA)|(0<<TWSTA)|(0<<TWSTO)|           // No Signal requests
             (0<<TWWC);                                 //
  }
}
 78a:	00 00       	nop
 78c:	00 00       	nop
 78e:	df 91       	pop	r29
 790:	cf 91       	pop	r28
 792:	ff 91       	pop	r31
 794:	ef 91       	pop	r30
 796:	9f 91       	pop	r25
 798:	8f 91       	pop	r24
 79a:	3f 91       	pop	r19
 79c:	2f 91       	pop	r18
 79e:	0f 90       	pop	r0
 7a0:	0f be       	out	0x3f, r0	; 63
 7a2:	0f 90       	pop	r0
 7a4:	1f 90       	pop	r1
 7a6:	18 95       	reti

000007a8 <__cmpsf2>:
 7a8:	0e 94 08 04 	call	0x810	; 0x810 <__fp_cmp>
 7ac:	08 f4       	brcc	.+2      	; 0x7b0 <__cmpsf2+0x8>
 7ae:	81 e0       	ldi	r24, 0x01	; 1
 7b0:	08 95       	ret

000007b2 <__fixunssfsi>:
 7b2:	0e 94 34 04 	call	0x868	; 0x868 <__fp_splitA>
 7b6:	88 f0       	brcs	.+34     	; 0x7da <__fixunssfsi+0x28>
 7b8:	9f 57       	subi	r25, 0x7F	; 127
 7ba:	98 f0       	brcs	.+38     	; 0x7e2 <__fixunssfsi+0x30>
 7bc:	b9 2f       	mov	r27, r25
 7be:	99 27       	eor	r25, r25
 7c0:	b7 51       	subi	r27, 0x17	; 23
 7c2:	b0 f0       	brcs	.+44     	; 0x7f0 <__fixunssfsi+0x3e>
 7c4:	e1 f0       	breq	.+56     	; 0x7fe <__fixunssfsi+0x4c>
 7c6:	66 0f       	add	r22, r22
 7c8:	77 1f       	adc	r23, r23
 7ca:	88 1f       	adc	r24, r24
 7cc:	99 1f       	adc	r25, r25
 7ce:	1a f0       	brmi	.+6      	; 0x7d6 <__fixunssfsi+0x24>
 7d0:	ba 95       	dec	r27
 7d2:	c9 f7       	brne	.-14     	; 0x7c6 <__fixunssfsi+0x14>
 7d4:	14 c0       	rjmp	.+40     	; 0x7fe <__fixunssfsi+0x4c>
 7d6:	b1 30       	cpi	r27, 0x01	; 1
 7d8:	91 f0       	breq	.+36     	; 0x7fe <__fixunssfsi+0x4c>
 7da:	0e 94 4e 04 	call	0x89c	; 0x89c <__fp_zero>
 7de:	b1 e0       	ldi	r27, 0x01	; 1
 7e0:	08 95       	ret
 7e2:	0c 94 4e 04 	jmp	0x89c	; 0x89c <__fp_zero>
 7e6:	67 2f       	mov	r22, r23
 7e8:	78 2f       	mov	r23, r24
 7ea:	88 27       	eor	r24, r24
 7ec:	b8 5f       	subi	r27, 0xF8	; 248
 7ee:	39 f0       	breq	.+14     	; 0x7fe <__fixunssfsi+0x4c>
 7f0:	b9 3f       	cpi	r27, 0xF9	; 249
 7f2:	cc f3       	brlt	.-14     	; 0x7e6 <__fixunssfsi+0x34>
 7f4:	86 95       	lsr	r24
 7f6:	77 95       	ror	r23
 7f8:	67 95       	ror	r22
 7fa:	b3 95       	inc	r27
 7fc:	d9 f7       	brne	.-10     	; 0x7f4 <__fixunssfsi+0x42>
 7fe:	3e f4       	brtc	.+14     	; 0x80e <__fixunssfsi+0x5c>
 800:	90 95       	com	r25
 802:	80 95       	com	r24
 804:	70 95       	com	r23
 806:	61 95       	neg	r22
 808:	7f 4f       	sbci	r23, 0xFF	; 255
 80a:	8f 4f       	sbci	r24, 0xFF	; 255
 80c:	9f 4f       	sbci	r25, 0xFF	; 255
 80e:	08 95       	ret

00000810 <__fp_cmp>:
 810:	99 0f       	add	r25, r25
 812:	00 08       	sbc	r0, r0
 814:	55 0f       	add	r21, r21
 816:	aa 0b       	sbc	r26, r26
 818:	e0 e8       	ldi	r30, 0x80	; 128
 81a:	fe ef       	ldi	r31, 0xFE	; 254
 81c:	16 16       	cp	r1, r22
 81e:	17 06       	cpc	r1, r23
 820:	e8 07       	cpc	r30, r24
 822:	f9 07       	cpc	r31, r25
 824:	c0 f0       	brcs	.+48     	; 0x856 <__fp_cmp+0x46>
 826:	12 16       	cp	r1, r18
 828:	13 06       	cpc	r1, r19
 82a:	e4 07       	cpc	r30, r20
 82c:	f5 07       	cpc	r31, r21
 82e:	98 f0       	brcs	.+38     	; 0x856 <__fp_cmp+0x46>
 830:	62 1b       	sub	r22, r18
 832:	73 0b       	sbc	r23, r19
 834:	84 0b       	sbc	r24, r20
 836:	95 0b       	sbc	r25, r21
 838:	39 f4       	brne	.+14     	; 0x848 <__fp_cmp+0x38>
 83a:	0a 26       	eor	r0, r26
 83c:	61 f0       	breq	.+24     	; 0x856 <__fp_cmp+0x46>
 83e:	23 2b       	or	r18, r19
 840:	24 2b       	or	r18, r20
 842:	25 2b       	or	r18, r21
 844:	21 f4       	brne	.+8      	; 0x84e <__fp_cmp+0x3e>
 846:	08 95       	ret
 848:	0a 26       	eor	r0, r26
 84a:	09 f4       	brne	.+2      	; 0x84e <__fp_cmp+0x3e>
 84c:	a1 40       	sbci	r26, 0x01	; 1
 84e:	a6 95       	lsr	r26
 850:	8f ef       	ldi	r24, 0xFF	; 255
 852:	81 1d       	adc	r24, r1
 854:	81 1d       	adc	r24, r1
 856:	08 95       	ret

00000858 <__fp_split3>:
 858:	57 fd       	sbrc	r21, 7
 85a:	90 58       	subi	r25, 0x80	; 128
 85c:	44 0f       	add	r20, r20
 85e:	55 1f       	adc	r21, r21
 860:	59 f0       	breq	.+22     	; 0x878 <__fp_splitA+0x10>
 862:	5f 3f       	cpi	r21, 0xFF	; 255
 864:	71 f0       	breq	.+28     	; 0x882 <__fp_splitA+0x1a>
 866:	47 95       	ror	r20

00000868 <__fp_splitA>:
 868:	88 0f       	add	r24, r24
 86a:	97 fb       	bst	r25, 7
 86c:	99 1f       	adc	r25, r25
 86e:	61 f0       	breq	.+24     	; 0x888 <__fp_splitA+0x20>
 870:	9f 3f       	cpi	r25, 0xFF	; 255
 872:	79 f0       	breq	.+30     	; 0x892 <__fp_splitA+0x2a>
 874:	87 95       	ror	r24
 876:	08 95       	ret
 878:	12 16       	cp	r1, r18
 87a:	13 06       	cpc	r1, r19
 87c:	14 06       	cpc	r1, r20
 87e:	55 1f       	adc	r21, r21
 880:	f2 cf       	rjmp	.-28     	; 0x866 <__fp_split3+0xe>
 882:	46 95       	lsr	r20
 884:	f1 df       	rcall	.-30     	; 0x868 <__fp_splitA>
 886:	08 c0       	rjmp	.+16     	; 0x898 <__fp_splitA+0x30>
 888:	16 16       	cp	r1, r22
 88a:	17 06       	cpc	r1, r23
 88c:	18 06       	cpc	r1, r24
 88e:	99 1f       	adc	r25, r25
 890:	f1 cf       	rjmp	.-30     	; 0x874 <__fp_splitA+0xc>
 892:	86 95       	lsr	r24
 894:	71 05       	cpc	r23, r1
 896:	61 05       	cpc	r22, r1
 898:	08 94       	sec
 89a:	08 95       	ret

0000089c <__fp_zero>:
 89c:	e8 94       	clt

0000089e <__fp_szero>:
 89e:	bb 27       	eor	r27, r27
 8a0:	66 27       	eor	r22, r22
 8a2:	77 27       	eor	r23, r23
 8a4:	cb 01       	movw	r24, r22
 8a6:	97 f9       	bld	r25, 7
 8a8:	08 95       	ret

000008aa <__gesf2>:
 8aa:	0e 94 08 04 	call	0x810	; 0x810 <__fp_cmp>
 8ae:	08 f4       	brcc	.+2      	; 0x8b2 <__gesf2+0x8>
 8b0:	8f ef       	ldi	r24, 0xFF	; 255
 8b2:	08 95       	ret

000008b4 <__mulsf3>:
 8b4:	0e 94 6d 04 	call	0x8da	; 0x8da <__mulsf3x>
 8b8:	0c 94 de 04 	jmp	0x9bc	; 0x9bc <__fp_round>
 8bc:	0e 94 d0 04 	call	0x9a0	; 0x9a0 <__fp_pscA>
 8c0:	38 f0       	brcs	.+14     	; 0x8d0 <__mulsf3+0x1c>
 8c2:	0e 94 d7 04 	call	0x9ae	; 0x9ae <__fp_pscB>
 8c6:	20 f0       	brcs	.+8      	; 0x8d0 <__mulsf3+0x1c>
 8c8:	95 23       	and	r25, r21
 8ca:	11 f0       	breq	.+4      	; 0x8d0 <__mulsf3+0x1c>
 8cc:	0c 94 c7 04 	jmp	0x98e	; 0x98e <__fp_inf>
 8d0:	0c 94 cd 04 	jmp	0x99a	; 0x99a <__fp_nan>
 8d4:	11 24       	eor	r1, r1
 8d6:	0c 94 4f 04 	jmp	0x89e	; 0x89e <__fp_szero>

000008da <__mulsf3x>:
 8da:	0e 94 2c 04 	call	0x858	; 0x858 <__fp_split3>
 8de:	70 f3       	brcs	.-36     	; 0x8bc <__mulsf3+0x8>

000008e0 <__mulsf3_pse>:
 8e0:	95 9f       	mul	r25, r21
 8e2:	c1 f3       	breq	.-16     	; 0x8d4 <__mulsf3+0x20>
 8e4:	95 0f       	add	r25, r21
 8e6:	50 e0       	ldi	r21, 0x00	; 0
 8e8:	55 1f       	adc	r21, r21
 8ea:	62 9f       	mul	r22, r18
 8ec:	f0 01       	movw	r30, r0
 8ee:	72 9f       	mul	r23, r18
 8f0:	bb 27       	eor	r27, r27
 8f2:	f0 0d       	add	r31, r0
 8f4:	b1 1d       	adc	r27, r1
 8f6:	63 9f       	mul	r22, r19
 8f8:	aa 27       	eor	r26, r26
 8fa:	f0 0d       	add	r31, r0
 8fc:	b1 1d       	adc	r27, r1
 8fe:	aa 1f       	adc	r26, r26
 900:	64 9f       	mul	r22, r20
 902:	66 27       	eor	r22, r22
 904:	b0 0d       	add	r27, r0
 906:	a1 1d       	adc	r26, r1
 908:	66 1f       	adc	r22, r22
 90a:	82 9f       	mul	r24, r18
 90c:	22 27       	eor	r18, r18
 90e:	b0 0d       	add	r27, r0
 910:	a1 1d       	adc	r26, r1
 912:	62 1f       	adc	r22, r18
 914:	73 9f       	mul	r23, r19
 916:	b0 0d       	add	r27, r0
 918:	a1 1d       	adc	r26, r1
 91a:	62 1f       	adc	r22, r18
 91c:	83 9f       	mul	r24, r19
 91e:	a0 0d       	add	r26, r0
 920:	61 1d       	adc	r22, r1
 922:	22 1f       	adc	r18, r18
 924:	74 9f       	mul	r23, r20
 926:	33 27       	eor	r19, r19
 928:	a0 0d       	add	r26, r0
 92a:	61 1d       	adc	r22, r1
 92c:	23 1f       	adc	r18, r19
 92e:	84 9f       	mul	r24, r20
 930:	60 0d       	add	r22, r0
 932:	21 1d       	adc	r18, r1
 934:	82 2f       	mov	r24, r18
 936:	76 2f       	mov	r23, r22
 938:	6a 2f       	mov	r22, r26
 93a:	11 24       	eor	r1, r1
 93c:	9f 57       	subi	r25, 0x7F	; 127
 93e:	50 40       	sbci	r21, 0x00	; 0
 940:	9a f0       	brmi	.+38     	; 0x968 <__stack+0x69>
 942:	f1 f0       	breq	.+60     	; 0x980 <__stack+0x81>
 944:	88 23       	and	r24, r24
 946:	4a f0       	brmi	.+18     	; 0x95a <__stack+0x5b>
 948:	ee 0f       	add	r30, r30
 94a:	ff 1f       	adc	r31, r31
 94c:	bb 1f       	adc	r27, r27
 94e:	66 1f       	adc	r22, r22
 950:	77 1f       	adc	r23, r23
 952:	88 1f       	adc	r24, r24
 954:	91 50       	subi	r25, 0x01	; 1
 956:	50 40       	sbci	r21, 0x00	; 0
 958:	a9 f7       	brne	.-22     	; 0x944 <__stack+0x45>
 95a:	9e 3f       	cpi	r25, 0xFE	; 254
 95c:	51 05       	cpc	r21, r1
 95e:	80 f0       	brcs	.+32     	; 0x980 <__stack+0x81>
 960:	0c 94 c7 04 	jmp	0x98e	; 0x98e <__fp_inf>
 964:	0c 94 4f 04 	jmp	0x89e	; 0x89e <__fp_szero>
 968:	5f 3f       	cpi	r21, 0xFF	; 255
 96a:	e4 f3       	brlt	.-8      	; 0x964 <__stack+0x65>
 96c:	98 3e       	cpi	r25, 0xE8	; 232
 96e:	d4 f3       	brlt	.-12     	; 0x964 <__stack+0x65>
 970:	86 95       	lsr	r24
 972:	77 95       	ror	r23
 974:	67 95       	ror	r22
 976:	b7 95       	ror	r27
 978:	f7 95       	ror	r31
 97a:	e7 95       	ror	r30
 97c:	9f 5f       	subi	r25, 0xFF	; 255
 97e:	c1 f7       	brne	.-16     	; 0x970 <__stack+0x71>
 980:	fe 2b       	or	r31, r30
 982:	88 0f       	add	r24, r24
 984:	91 1d       	adc	r25, r1
 986:	96 95       	lsr	r25
 988:	87 95       	ror	r24
 98a:	97 f9       	bld	r25, 7
 98c:	08 95       	ret

0000098e <__fp_inf>:
 98e:	97 f9       	bld	r25, 7
 990:	9f 67       	ori	r25, 0x7F	; 127
 992:	80 e8       	ldi	r24, 0x80	; 128
 994:	70 e0       	ldi	r23, 0x00	; 0
 996:	60 e0       	ldi	r22, 0x00	; 0
 998:	08 95       	ret

0000099a <__fp_nan>:
 99a:	9f ef       	ldi	r25, 0xFF	; 255
 99c:	80 ec       	ldi	r24, 0xC0	; 192
 99e:	08 95       	ret

000009a0 <__fp_pscA>:
 9a0:	00 24       	eor	r0, r0
 9a2:	0a 94       	dec	r0
 9a4:	16 16       	cp	r1, r22
 9a6:	17 06       	cpc	r1, r23
 9a8:	18 06       	cpc	r1, r24
 9aa:	09 06       	cpc	r0, r25
 9ac:	08 95       	ret

000009ae <__fp_pscB>:
 9ae:	00 24       	eor	r0, r0
 9b0:	0a 94       	dec	r0
 9b2:	12 16       	cp	r1, r18
 9b4:	13 06       	cpc	r1, r19
 9b6:	14 06       	cpc	r1, r20
 9b8:	05 06       	cpc	r0, r21
 9ba:	08 95       	ret

000009bc <__fp_round>:
 9bc:	09 2e       	mov	r0, r25
 9be:	03 94       	inc	r0
 9c0:	00 0c       	add	r0, r0
 9c2:	11 f4       	brne	.+4      	; 0x9c8 <__fp_round+0xc>
 9c4:	88 23       	and	r24, r24
 9c6:	52 f0       	brmi	.+20     	; 0x9dc <__fp_round+0x20>
 9c8:	bb 0f       	add	r27, r27
 9ca:	40 f4       	brcc	.+16     	; 0x9dc <__fp_round+0x20>
 9cc:	bf 2b       	or	r27, r31
 9ce:	11 f4       	brne	.+4      	; 0x9d4 <__fp_round+0x18>
 9d0:	60 ff       	sbrs	r22, 0
 9d2:	04 c0       	rjmp	.+8      	; 0x9dc <__fp_round+0x20>
 9d4:	6f 5f       	subi	r22, 0xFF	; 255
 9d6:	7f 4f       	sbci	r23, 0xFF	; 255
 9d8:	8f 4f       	sbci	r24, 0xFF	; 255
 9da:	9f 4f       	sbci	r25, 0xFF	; 255
 9dc:	08 95       	ret

000009de <fwrite>:
 9de:	b0 e0       	ldi	r27, 0x00	; 0
 9e0:	a0 e0       	ldi	r26, 0x00	; 0
 9e2:	e5 ef       	ldi	r30, 0xF5	; 245
 9e4:	f4 e0       	ldi	r31, 0x04	; 4
 9e6:	0c 94 23 05 	jmp	0xa46	; 0xa46 <__prologue_saves__+0xc>
 9ea:	4c 01       	movw	r8, r24
 9ec:	7b 01       	movw	r14, r22
 9ee:	6a 01       	movw	r12, r20
 9f0:	89 01       	movw	r16, r18
 9f2:	d9 01       	movw	r26, r18
 9f4:	13 96       	adiw	r26, 0x03	; 3
 9f6:	8c 91       	ld	r24, X
 9f8:	d0 e0       	ldi	r29, 0x00	; 0
 9fa:	c0 e0       	ldi	r28, 0x00	; 0
 9fc:	81 ff       	sbrs	r24, 1
 9fe:	17 c0       	rjmp	.+46     	; 0xa2e <fwrite+0x50>
 a00:	cc 15       	cp	r28, r12
 a02:	dd 05       	cpc	r29, r13
 a04:	a1 f0       	breq	.+40     	; 0xa2e <fwrite+0x50>
 a06:	54 01       	movw	r10, r8
 a08:	ae 0c       	add	r10, r14
 a0a:	bf 1c       	adc	r11, r15
 a0c:	0b c0       	rjmp	.+22     	; 0xa24 <fwrite+0x46>
 a0e:	d8 01       	movw	r26, r16
 a10:	18 96       	adiw	r26, 0x08	; 8
 a12:	ed 91       	ld	r30, X+
 a14:	fc 91       	ld	r31, X
 a16:	b8 01       	movw	r22, r16
 a18:	d4 01       	movw	r26, r8
 a1a:	8d 91       	ld	r24, X+
 a1c:	4d 01       	movw	r8, r26
 a1e:	09 95       	icall
 a20:	89 2b       	or	r24, r25
 a22:	29 f4       	brne	.+10     	; 0xa2e <fwrite+0x50>
 a24:	8a 14       	cp	r8, r10
 a26:	9b 04       	cpc	r9, r11
 a28:	91 f7       	brne	.-28     	; 0xa0e <fwrite+0x30>
 a2a:	21 96       	adiw	r28, 0x01	; 1
 a2c:	e9 cf       	rjmp	.-46     	; 0xa00 <fwrite+0x22>
 a2e:	ce 01       	movw	r24, r28
 a30:	cd b7       	in	r28, 0x3d	; 61
 a32:	de b7       	in	r29, 0x3e	; 62
 a34:	ec e0       	ldi	r30, 0x0C	; 12
 a36:	0c 94 3f 05 	jmp	0xa7e	; 0xa7e <__epilogue_restores__+0xc>

00000a3a <__prologue_saves__>:
 a3a:	2f 92       	push	r2
 a3c:	3f 92       	push	r3
 a3e:	4f 92       	push	r4
 a40:	5f 92       	push	r5
 a42:	6f 92       	push	r6
 a44:	7f 92       	push	r7
 a46:	8f 92       	push	r8
 a48:	9f 92       	push	r9
 a4a:	af 92       	push	r10
 a4c:	bf 92       	push	r11
 a4e:	cf 92       	push	r12
 a50:	df 92       	push	r13
 a52:	ef 92       	push	r14
 a54:	ff 92       	push	r15
 a56:	0f 93       	push	r16
 a58:	1f 93       	push	r17
 a5a:	cf 93       	push	r28
 a5c:	df 93       	push	r29
 a5e:	cd b7       	in	r28, 0x3d	; 61
 a60:	de b7       	in	r29, 0x3e	; 62
 a62:	ca 1b       	sub	r28, r26
 a64:	db 0b       	sbc	r29, r27
 a66:	0f b6       	in	r0, 0x3f	; 63
 a68:	f8 94       	cli
 a6a:	de bf       	out	0x3e, r29	; 62
 a6c:	0f be       	out	0x3f, r0	; 63
 a6e:	cd bf       	out	0x3d, r28	; 61
 a70:	09 94       	ijmp

00000a72 <__epilogue_restores__>:
 a72:	2a 88       	ldd	r2, Y+18	; 0x12
 a74:	39 88       	ldd	r3, Y+17	; 0x11
 a76:	48 88       	ldd	r4, Y+16	; 0x10
 a78:	5f 84       	ldd	r5, Y+15	; 0x0f
 a7a:	6e 84       	ldd	r6, Y+14	; 0x0e
 a7c:	7d 84       	ldd	r7, Y+13	; 0x0d
 a7e:	8c 84       	ldd	r8, Y+12	; 0x0c
 a80:	9b 84       	ldd	r9, Y+11	; 0x0b
 a82:	aa 84       	ldd	r10, Y+10	; 0x0a
 a84:	b9 84       	ldd	r11, Y+9	; 0x09
 a86:	c8 84       	ldd	r12, Y+8	; 0x08
 a88:	df 80       	ldd	r13, Y+7	; 0x07
 a8a:	ee 80       	ldd	r14, Y+6	; 0x06
 a8c:	fd 80       	ldd	r15, Y+5	; 0x05
 a8e:	0c 81       	ldd	r16, Y+4	; 0x04
 a90:	1b 81       	ldd	r17, Y+3	; 0x03
 a92:	aa 81       	ldd	r26, Y+2	; 0x02
 a94:	b9 81       	ldd	r27, Y+1	; 0x01
 a96:	ce 0f       	add	r28, r30
 a98:	d1 1d       	adc	r29, r1
 a9a:	0f b6       	in	r0, 0x3f	; 63
 a9c:	f8 94       	cli
 a9e:	de bf       	out	0x3e, r29	; 62
 aa0:	0f be       	out	0x3f, r0	; 63
 aa2:	cd bf       	out	0x3d, r28	; 61
 aa4:	ed 01       	movw	r28, r26
 aa6:	08 95       	ret

00000aa8 <_exit>:
 aa8:	f8 94       	cli

00000aaa <__stop_program>:
 aaa:	ff cf       	rjmp	.-2      	; 0xaaa <__stop_program>
